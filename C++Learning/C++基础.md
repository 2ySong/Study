# Day-01 C++入门

## 001 运行环境

- 编辑器：我用的是vs code+mingw
- 记住要切换为GBK编码

## 002 Hello,World!

- C++基本框架

  ```c++
  #include<iostream>
  using namespace std;
  
  int main(){
      cout <<"hello C++" << endl;
      system("pause");
      return 0;
  }
  ```

## 003 注释

- 作用: 在代码中加一些说明和解释，方便自己或其他程序员程序员阅读代码

- 两种格式

  1. 单行注释：`//描述信息`
     - 通常放在一行代码的上方，或者一条语句的末尾，对该行代码说明
  2. 多行注释：`/*描述信息*/`
     - 通常放茌一段代码的上方，对该段代码做整体说明

  > 提示：编译器在编译代码时，会忽略注释的内容。 

## 004 变量与常量

**变量**

- **作用**：给一段指定的内存空间起名，方便操作这段内存

- 变量存在的意义：方便我们管理内存空间。

- **语法**：`数据类型 变量名 = 初始值;`

- **示例**：
  
  ```c++
  int a = 10;
  cout <<"a = " <<a<< endl;//输出变量a当前的值
  ```

**常量**

- 作用: 用开记录程序中不可更改的数据。
- C++定义常量两种方式
  1. **\#define**宏常量：`#define  常量名 常量值`
     通常在文件上方定义，表示一个常量
  2. **const**修饰的变量：`const 数据类型 常量名 = 常量值`
     通常在变量定义前加关键字 const，修饰该变量为常量，==不可修改==

## 005 关键字

**作用**：关键字是C++中预先保留的单词(**标识符**)

- 在定义变量或者常量时，不要用关键字

<img src="https://gitee.com/song-zhangyao/mapdepot1/raw/master/typora/202111031432123.png" alt="image-20211020135207589" style="zoom:67%;" />

> 提示：在给变量或者常量起名称时候，不要用关键字，否则会产生歧义

---

## 006 标识符命名规则

**作用**：C++规定给标识符(变量、常量)命名时，有一套自己的规则。

1. 标识符不能是关键字

2. 标识符只能由字母、数字、下划线组成

3. **第一个字符必须为字母或下划线**

4. 标识符中字母区分==大小写==

   > 建议：给标识符命名时，争取做到见名知意的效果，方便自己和他人的阅读。

---

# Day-02 数据类型

- C++规定在创建一个变量或者常量时，必须要指定出相应的数据类型，否则无法给变量分配内存。

## 007 整型

**作用**：整型变量表示的是==整数类型==的数据。

C++中能够表示整型的类型有以下几种方式，区别在于所占内存空间不同:

|      数据类型       |                    占用空间                     |       取值范围       |
| :-----------------: | :---------------------------------------------: | :------------------: |
|    short(短整型)    |                      2字节                      | （-2^15^ ~ 2^15^-1） |
|     int(短整型)     |                      4字节                      | （-2^31^ ~ 2^31^-1） |
|    long(长整型)     | Windows为4字节，Linux为4字节(32位)，8字节(64位) | （-2^31^ ~ 2^31^-1） |
| long long(长长整型) |                      8字节                      | （-2^63^ ~ 2^63^-1） |

## 008 sizeof关键字

**作用**：利用 sizeof关键字可以统计数据类型所占内存大小。

**语法**: `sizeof(数据类型 / 变量)`

示例：

```c++
int main(){
    cout<<"1. short类型所占的内存空间为"<< sizeof(short) << "字节\n" << endl;
    cout<<"2. int类型所占的内存空间为"<< sizeof(int) << "字节\n" << endl;
    cout<<"3. long类型所占的内存空间为"<< sizeof(long) << "字节\n" << endl;
    cout<<"4. long long类型所占的内存空间为"<< sizeof(long long) << "字节\n" << endl;
    system("pause");
    return 0;
}
```

输出：<img src="https://gitee.com/song-zhangyao/mapdepot1/raw/master/typora/202111031430566.png" alt="image-20211020144357146" width="300" />

---

## 009 实型(浮点型)

**作用**：用于表示小数

- 浮点型变量分为两种：
  1. float：单精度
  2. double：双精度

- 两者的区别在于表示的有效数字范围不同

  | 数据类型 | 占用空间 | 有效数字范围 |
  | :------: | :------: | :----------: |
  |  float   |  4字节   |     7位      |
  |  double  |  8字节   |   15~16位    |

- 示例

  ```c++
  float f1 = 3.14f;
  double d1 = 3.14;
  //科学计数法
  float f2 = 3e2;//3*10^2
  ```

  - 注意：用float初始化变量时，要在初值后面+'f'，而double不用

  - 科学计数法：

    1. `float f2 = 3e2;`表示`3×10²`
    2. `float f3 = 3e-2;`表示3×10^-2^

    ----

## 0010 字符型

**作用**：字符型变量用于显示单个字符

**语法**： `char ch = 'a';`

- 注意1：在显示字符型变量时，用**单引号**将字符括起来，不要用双引号
- 注意2：单引号内只能有一个字符，不可以是字符串

- C和C++中字符型变量只==占用1个字节==。

- 字符型变量并不是把字符本身放到内存中存储，而是将==对应的ASCII编码==放入到存储单元

---

## 0011 转义字符 

**作用**：用于表示一些不能显示出来的ASC字符

- 现阶段我们常用的转义字符有：`\n,\t`

- 常用的转义字符

  | 转义字符 |             含义             | ASCII码值(十进制) |
  | :------: | :--------------------------: | :---------------: |
  |   `\a`   |          蜂鸣，响铃          |        007        |
  |   `\b`   |     回退(BS)：向后退一格     |        008        |
  |   `\f`   |           换页(FF)           |        012        |
  |   `\n`   | **换行(LF)，光标到下行行首** |        010        |
  |   `\r`   |   回车(CR)，光标到本行行首   |        013        |
  |   `\t`   |         水平制表(HT)         |        009        |
  |   `\v`   |         垂直制表(VT)         |        011        |
  |   `\\`   |            反斜杠            |        092        |
  |   `\'`   |            单引号            |        039        |
  |   `\"`   |            双引号            |        034        |
  |   `\?`   |             问号             |        063        |
  |   `\0`   |   空字符(NULL),什么都不做    |        000        |

---

## 0012 字符串类型

**作用**：用于表示一串字符。

- 两种风格：

  1. C语言风格字符串：`char 变量名[] = "字符串值";`

     ```c
     char str[] = "abcde";
     ```

  2. C++风格字符串：

     用这种风格，要加一个头文件`#include<string>`

     ```c++
     string str = "abcde";
     ```

## 0013 布尔数据类型

**作用**：布尔数据类型代表==真或假==的值

- **bool**类型只有两个值
  1. true--真(本质是1)
  2. false--假(本质是0)

- **bool**类型占==1个字节==大小。

- 示例

  ```c++
  bool flag = true;
  cout << flag << endl;//本质是1
  ```

## 0014 数据的输入

**作用**：用于从键盘获取数据

- 关键字：`cin`

- 语法：`cin >> 变量;`

- 示例：

  ```c++
  int main(){
      //1. 输入一个整型
      int a = 0;
      cout << "1. 请输入一个整型数据：" << endl;
      cin >> a;
      cout << "整型 = " <<  a << endl;
  
      //2. 输入一个浮点型
      double b = 0;
      cout << "2. 请输入一个浮点型型数据：" << endl;
      cin >> b;
      cout << "浮点型b = " << b << endl;
  
      //3. 输入一个字符型
      char c = 'A';
      cout << "3. 请输入一个字符型数据：" << endl;
      cin >> c;
      cout << "字符型c = " << c << endl;
  
      //4. 输入一个字符型
      string d = "琪琪子";
      cout << "4. 请输入一个字符串型数据：" << endl;
      cin >> d;
      cout << "字符串型d = " << d << endl;
  
      //5. bool数据类型
      bool e = false;
      cout << "5. 请输入一个布尔型数据：" << endl;
      cin >> e;//可以输入数字，除了0都是true
      cout << "布尔型e = " << e <<endl;
  
      system("pause");
      return 0;
  }
  ```

---



# Day-03 运算符

## 0015 算术运算符

下表显示了 C++ 支持的算术运算符。

**假设变量 A 的值为 10，变量 B 的值为 20，则**：

| 运算符 |                             描述                             |       实例       |
| :----: | :----------------------------------------------------------: | :--------------: |
|   +    |                       把两个操作数相加                       | A + B 将得到 30  |
|   -    |               从第一个操作数中减去第二个操作数               | A - B 将得到 -10 |
|   *    |                       把两个操作数相乘                       | A * B 将得到 200 |
|   /    |                         分子除以分母                         |  B / A 将得到 2  |
|   %    |                 ==取模==运算符，整除后的余数                 | 10 % 3 将得到 1  |
|   ++   | [自增运算符](https://www.runoob.com/cplusplus/cpp-increment-decrement-operators.html)，整数值增加 1 |  A++ 将得到 11   |
|   ++   |                                                              |                  |
|   --   | [自减运算符](https://www.runoob.com/cplusplus/cpp-increment-decrement-operators.html)，整数值减少 1 |   A-- 将得到 9   |

- 注意：两个小数不能用==取模运算==



## 0016 赋值运算符

下表列出了 C++ 支持的赋值运算符：

| 运算符 |                             描述                             |              实例               |
| :----: | :----------------------------------------------------------: | :-----------------------------: |
|   =    |       简单的赋值运算符，把右边操作数的值赋给左边操作数       | C = A + B 将把 A + B 的值赋给 C |
|   +=   | 加且赋值运算符，把右边操作数加上左边操作数的结果赋值给左边操作数 |     C += A 相当于 C = C + A     |
|   -=   | 减且赋值运算符，把左边操作数减去右边操作数的结果赋值给左边操作数 |     C -= A 相当于 C = C - A     |
|   *=   | 乘且赋值运算符，把右边操作数乘以左边操作数的结果赋值给左边操作数 |     C *= A 相当于 C = C * A     |
|   /=   | 除且赋值运算符，把左边操作数除以右边操作数的结果赋值给左边操作数 |     C /= A 相当于 C = C / A     |
|   %=   |      求模且赋值运算符，求两个操作数的模赋值给左边操作数      |     C %= A 相当于 C = C % A     |
|  <<=   |                       左移且赋值运算符                       |    C <<= 2 等同于 C = C << 2    |
|  >>=   |                       右移且赋值运算符                       |    C >>= 2 等同于 C = C >> 2    |
|   &=   |                      按位与且赋值运算符                      |     C &= 2 等同于 C = C & 2     |
|   ^=   |                     按位异或且赋值运算符                     |     C ^= 2 等同于 C = C ^ 2     |
|  \|=   |                      按位或且赋值运算符                      |    C \|= 2 等同于 C = C \| 2    |



## 0017 关系运算符

下表显示了 C++ 支持的关系运算符。

**假设变量 A 的值为 10，变量 B 的值为 20，则**：

| 运算符 |                             描述                             |       实例        |
| :----: | :----------------------------------------------------------: | :---------------: |
|   ==   |       检查两个操作数的值是否相等，如果相等则条件为真。       | (A == B) 不为真。 |
|   !=   |      检查两个操作数的值是否相等，如果不相等则条件为真。      |  (A != B) 为真。  |
|   >    |   检查左操作数的值是否大于右操作数的值，如果是则条件为真。   | (A > B) 不为真。  |
|   <    |   检查左操作数的值是否小于右操作数的值，如果是则条件为真。   |  (A < B) 为真。   |
|   >=   | 检查左操作数的值是否大于或等于右操作数的值，如果是则条件为真。 | (A >= B) 不为真。 |
|   <=   | 检查左操作数的值是否小于或等于右操作数的值，如果是则条件为真。 |  (A <= B) 为真。  |

示例：

```c++
#include <iostream>
using namespace std;

int main()
{
    int a = 21;
    int c;

    c = a;
    cout << "a = 21; c = a; c 的值 =  " << c << endl; //21

    c = 0;
    c += a;
    cout << "a = 21; c += a; c 的值 =  " << c << endl; //21
    c = 0;
    c -= a;
    cout << "a = 21; c -= a; c 的值 =  " << c << endl; //-21

    c = 0;
    c *= a;
    cout << "a = 21; c *= a; c 的值 =  " << c << endl; //0

    c = 42;
    c /= a;
    cout << "a = 21; c = 42; c /= a; c 的值 =  " << c << endl; //2

    c = 200;
    c %= a;
    cout << "a = 21; c=200; c %= a; c 的值 =  " << c << endl; //11

    c = 15;
    c <<= 2;
    cout << "c = 15; c <<=2; c 的值 =  " << c << endl;//400

    c = 15;
    c >>= 2;
    cout << "c = 15; c >>= 2; c 的值 =  " << c << endl;//60

    c = 1;
    c &= 2;
    cout << "c = 1; c &= 2; c 的值 =  " << c << endl;//1

    c = 1;
    c ^= 2;
    cout << "c = 1; c ^= 2; c 的值 =  " << c << endl; //3

    c = 1;
    c |= 2;
    cout << "c = 1; c |=2; c 的值 =  " << c << endl; //2

    system("pause");
    return 0;
}
```

---

## 0018 逻辑运算符

下表显示了 C++ 支持的关系逻辑运算符。

假设变量 A 的值为 1，变量 B 的值为 0，则：

| 运算符 | 描述                                                         | 实例                 |
| :----- | :----------------------------------------------------------- | :------------------- |
| &&     | 称为逻辑与运算符。如果两个操作数都 true，则条件为 true。     | (A && B) 为 false。  |
| \|\|   | 称为逻辑或运算符。如果两个操作数中有任意一个 true，则条件为 true。 | (A \|\| B) 为 true。 |
| !      | 称为逻辑非运算符。用来逆转操作数的逻辑状态，如果条件为 true 则逻辑非运算符将使其为 false。 | !(A && B) 为 true。  |

**实例**

```c++
#include <iostream>
using namespace std;
 
int main()
{
   int a = 5;
   int b = 20;
   int c ;
 
   if ( a && b )
   {
      cout << "Line 1 - 条件为真"<< endl ;
   }
   if ( a || b )
   {
      cout << "Line 2 - 条件为真"<< endl ;
   }
   /* 改变 a 和 b 的值 */
   a = 0;
   b = 10;
   if ( a && b )//false
   {
      cout << "Line 3 - 条件为真"<< endl ;
   }
   else
   {
      cout << "Line 4 - 条件不为真"<< endl ;
   }
   if ( !(a && b) )
   {
      cout << "Line 5 - 条件为真"<< endl ;
   }
   return 0;
}
```

---

## 0019 位运算符

**作用于位，并逐位执行操作。&、 | 和 ^ 的真值表如下所示：**

|  p   |  q   | p & q | p \| q | p ^ q |
| :--: | :--: | :---: | :----: | :---: |
|  0   |  0   |   0   |   0    |   0   |
|  0   |  1   |   0   |   1    |   1   |
|  1   |  1   |   1   |   1    |   0   |
|  1   |  0   |   0   |   1    |   1   |

- 假设如果 A = 60，且 B = 13，现在以二进制格式表示，它们如下所示：

  A = 0011 1100

  B = 0000 1101

  \-----------------

  A&B = 0000 1100

  A|B = 0011 1101

  A^B = 0011 0001

  ~A = 1100 0011

- 下表显示了 C++ 支持的位运算符。假设变量 A 的值为 60，变量 B 的值为 13，则：

| 运算符 | 描述                                                         | 实例                                                         |
| :----- | :----------------------------------------------------------- | :----------------------------------------------------------- |
| &      | 按位与操作，按二进制位进行"与"运算。运算规则：`0&0=0;    0&1=0;     1&0=0;      1&1=1;` | (A & B) 将得到 12，即为 0000 1100                            |
| \|     | 按位或运算符，按二进制位进行"或"运算。运算规则：`0|0=0;    0|1=1;    1|0=1;     1|1=1;` | (A \| B) 将得到 61，即为 0011 1101                           |
| ^      | 异或运算符，按二进制位进行"异或"运算。运算规则：`0^0=0;    0^1=1;    1^0=1;   1^1=0;` | (A ^ B) 将得到 49，即为 0011 0001                            |
| ~      | 取反运算符，按二进制位进行"取反"运算。运算规则：`~1=-2;    ~0=-1;` | (~A ) 将得到 -61，即为 1100 0011，一个有符号二进制数的补码形式。 |
| <<     | 二进制左移运算符。将一个运算对象的各二进制位全部左移若干位（左边的二进制位丢弃，右边补0）。 | A << 2 将得到 240，即为 1111 0000                            |
| >>     | 二进制右移运算符。将一个数的各二进制位全部右移若干位，正数左补0，负数左补1，右边丢弃。 |                                                              |

- **示例：**

```c++
#include <iostream>
using namespace std;
 
int main()
{
   unsigned int a = 60;      // 60 = 0011 1100  
   unsigned int b = 13;      // 13 = 0000 1101
   int c = 0;           
 
   c = a & b;             // 12 = 0000 1100
   cout << "Line 1 - c 的值是 " << c << endl ;
 
   c = a | b;             // 61 = 0011 1101
   cout << "Line 2 - c 的值是 " << c << endl ;
 
   c = a ^ b;             // 49 = 0011 0001
   cout << "Line 3 - c 的值是 " << c << endl ;
 
   c = ~a;                // -61 = 1100 0011
   cout << "Line 4 - c 的值是 " << c << endl ;
 
   c = a << 2;            // 240 = 1111 0000
   cout << "Line 5 - c 的值是 " << c << endl ;
 
   c = a >> 2;            // 15 = 0000 1111
   cout << "Line 6 - c 的值是 " << c << endl ;
 
   return 0;
}
```

---



# Day-04 程序流程结构

## 0020 循环结构

有的时候，可能需要多次执行同一块代码。一般情况下，语句是顺序执行的：函数中的第一个语句先执行，接着是第二个语句，依此类推。

编程语言提供了允许更为复杂的执行路径的多种控制结构。

循环语句允许我们多次执行一个语句或语句组，下面是大多数编程语言中循环语句的一般形式：

 <img src="https://gitee.com/song-zhangyao/mapdepot1/raw/master/typora/202111031429998.png" alt="循环结构" width=450 />

### 循环类型

C++ 编程语言提供了以下几种循环类型。点击链接查看每个类型的细节。

| 循环类型                                                     | 描述                                                         |
| :----------------------------------------------------------- | :----------------------------------------------------------- |
| [while 循环](https://www.runoob.com/cplusplus/cpp-while-loop.html) | 当给定条件为真时，重复语句或语句组。它会在执行循环主体之前测试条件。 |
| [for 循环](https://www.runoob.com/cplusplus/cpp-for-loop.html) | 多次执行一个语句序列，简化管理循环变量的代码。               |
| [do...while 循环](https://www.runoob.com/cplusplus/cpp-do-while-loop.html) | 除了它是在循环主体结尾测试条件外，其他与 while 语句类似。    |
| [嵌套循环](https://www.runoob.com/cplusplus/cpp-nested-loops.html) | 您可以在 while、for 或 do..while 循环内使用一个或多个循环。  |



### 循环控制语句

循环控制语句更改执行的正常序列。当执行离开一个范围时，所有在该范围中创建的自动对象都会被销毁。

C++ 提供了下列的控制语句。点击链接查看每个语句的细节。

| 控制语句                                                     | 描述                                                         |
| :----------------------------------------------------------- | :----------------------------------------------------------- |
| [break 语句](https://www.runoob.com/cplusplus/cpp-break-statement.html) | 终止 **loop** 或 **switch** 语句，程序流将继续执行紧接着 loop 或 switch 的下一条语句。 |
| [continue 语句](https://www.runoob.com/cplusplus/cpp-continue-statement.html) | 引起循环跳过主体的剩余部分，立即重新开始测试条件。           |
| [goto 语句](https://www.runoob.com/cplusplus/cpp-goto-statement.html) | 将控制转移到被标记的语句。但是==不建议在程序中使用 goto 语句。== |



### 无限循环

如果条件永远不为假，则循环将变成无限循环。**for** 循环在传统意义上可用于实现无限循环。由于构成循环的三个表达式中任何一个都不是必需的，您可以将某些条件表达式留空来构成一个无限循环。

**实例**

```c++
#include <iostream> 
using namespace std;  
int main () {    
    for( ; ; )   {      
        printf("This loop will run forever.\n");   
    }    
    return 0; 
}
```

当条件表达式不存在时，它被假设为真。您也可以设置一个初始值和增量表达式，但是一般情况下，C++ 程序员偏向于使用 for(;;) 结构来表示一个无限循环。

**注意：**您可以按 Ctrl + C 键终止一个无限循环。

---

## 0021 条件判断

判断结构要求程序员指定一个或多个要评估或测试的条件，以及条件为真时要执行的语句（必需的）和条件为假时要执行的语句（可选的）。

下面是大多数编程语言中典型的判断结构的一般形式：

 <img src="https://gitee.com/song-zhangyao/mapdepot1/raw/master/typora/202111031429290.png" alt="C++ 中的判断语句" width=400 />

### 判断语句

C++ 编程语言提供了以下类型的判断语句。点击链接查看每个语句的细节。

| 语句                                                         | 描述                                                         |
| :----------------------------------------------------------- | :----------------------------------------------------------- |
| [if 语句](https://www.runoob.com/cplusplus/cpp-if.html)      | 一个 **if 语句** 由一个布尔表达式后跟一个或多个语句组成。    |
| [if...else 语句](https://www.runoob.com/cplusplus/cpp-if-else.html) | 一个 **if 语句** 后可跟一个可选的 **else 语句**，else 语句在布尔表达式为假时执行。 |
| [嵌套 if 语句](https://www.runoob.com/cplusplus/cpp-nested-if.html) | 您可以在一个 **if** 或 **else if** 语句内使用另一个 **if** 或 **else if** 语句。 |
| [switch 语句](https://www.runoob.com/cplusplus/cpp-switch.html) | 一个 **switch** 语句允许测试一个变量等于多个值时的情况。     |
| [嵌套 switch 语句](https://www.runoob.com/cplusplus/cpp-nested-switch.html) | 您可以在一个 **switch** 语句内使用另一个 **switch** 语句。   |

### switch 语句

[![C++ 判断](C++基础.assets/up-16347998317911.gif) C++ 判断](https://www.runoob.com/cplusplus/cpp-decision.html)

一个 **switch** 语句允许测试一个变量等于多个值时的情况。每个值称为一个 case，且被测试的变量会对每个 **switch case** 进行检查。

**语法**

C++ 中 **switch** 语句的语法：

```c++
switch (变量)
{
    case 常量1:
        statement(s);
        break; // 可选的
    case 常量2:
        statement(s);
        break; // 可选的
        // 您可以有任意数量的 case 语句
    default:   // 可选的
        statement(s);
}
```

**switch** 语句必须遵循下面的规则：

- switch不能判断**区间**。

- **switch** 语句中的 **expression** 必须是一个==整型或字符型==，或者是一个 class 类型，其中 class 有一个单一的转换函数将其转换为整型或枚举类型。
- 在一个 switch 中可以有任意数量的 case 语句。每个 case 后跟一个要比较的值和一个冒号。
- case 的 **constant-expression** 必须与 switch 中的变量具有相同的数据类型，且必须是一个常量或字面量。
- 当被测试的变量等于 case 中的常量时，case 后跟的语句将被执行，直到遇到 **break** 语句为止。
- 当遇到 **break** 语句时，switch 终止，控制流将跳转到 switch 语句后的下一行。
- 不是每一个 case 都需要包含 **break**。如果 case 语句不包含 **break**，控制流将会 *继续* 后续的 case，直到遇到 break 为止。
- 一个 **switch** 语句可以有一个可选的 **default** case，出现在 switch 的结尾。default case 可用于在上面所有 case 都不为真时执行一个任务。default case 中的 **break** 语句不是必需的。

**流程图**

![C++ 中的 switch 语句](https://gitee.com/song-zhangyao/mapdepot1/raw/master/typora/202111031429900.jpg)

**实例**

```c++
#include <iostream>
using namespace std;
int main()
{
    // 局部变量声明
    char grade = 'D';
    switch (grade)
    {
    case 'A':
        cout << "很棒！" << endl;
        break;
    case 'B':
    case 'C':
        cout << "做得好" << endl;
        break;
    case 'D':
        cout << "您通过了" << endl;
        break;
    case 'F':
        cout << "最好再试一下" << endl;
        break;
    default:
        cout << "无效的成绩" << endl;
    }
    cout << "您的成绩是 " << grade << endl;
    return 0;
}
```



### 嵌套 switch 语句

可以把一个 **switch** 作为一个外部 **switch** 的语句序列的一部分，即可以在一个 **switch** 语句内使用另一个 **switch** 语句。即使内部和外部 switch 的 case 常量包含共同的值，也没有矛盾。

C++ 中的 switch 语句允许至少 256 个嵌套层次。

**语法**

C++ 中 **嵌套 switch** 语句的语法：

```c++
switch(ch1) {
   case 'A': 
      cout << "这个 A 是外部 switch 的一部分";
      switch(ch2) {
         case 'A':
            cout << "这个 A 是内部 switch 的一部分";
            break;
         case 'B': // 内部 B case 代码
      }
      break;
   case 'B': // 外部 B case 代码
}
```

**实例**

```c++
#include <iostream>
using namespace std;

int main ()
{
  // 局部变量声明
  int a = 100;
  int b = 200;

  switch(a) {
   case 100:
     cout << "这是外部 switch 的一部分" << endl;
     switch(b) {
      case 200:
        cout << "这是内部 switch 的一部分" << endl;
     }
  }
  cout << "a 的准确值是 " << a << endl;
  cout << "b 的准确值是 " << b << endl;

  return 0;
}
```



### 三目运算符 ? : 

我们已经在前面的章节中讲解了 [**条件运算符 ? :**](https://www.runoob.com/cplusplus/cpp-conditional-operator.html)，可以用来替代 **if...else** 语句。它的一般形式如下：

```
Exp1 ? Exp2 : Exp3;
```

其中，Exp1、Exp2 和 Exp3 是表达式。请注意，冒号的使用和位置。

? 表达式的值是由 Exp1 决定的。如果 Exp1 为真，则计算 Exp2 的值，结果即为整个 ? 表达式的值。如果 Exp1 为假，则计算 Exp3 的值，结果即为整个 ? 表达式的值。

---

# Day-05 数组



C++ 支持**数组**数据结构，它可以存储一个固定大小的相同类型元素的顺序集合。数组是用来存储一系列数据，但它往往被认为是一系列相同类型的变量。

数组的声明并不是声明一个个单独的变量，比如 number0、number1、...、number99，而是声明一个数组变量，比如 numbers，然后使用 numbers[0]、numbers[1]、...、numbers[99] 来代表一个个单独的变量。数组中的特定元素可以通过索引访问。

所有的数组都是由连续的内存位置组成。最低的地址对应第一个元素，最高的地址对应最后一个元素。

## 0022 一维数组

### 1. 声明数组

在 C++ 中要声明一个数组，需要指定元素的类型和元素的数量，如下所示：

```
type arrayName [ arraySize ];
```

这叫做一维数组。**arraySize** 必须是一个大于零的整数常量，**type** 可以是任意有效的 C++ 数据类型。例如，要声明一个类型为 double 的包含 10 个元素的数组 **balance**，声明语句如下：

```
double balance[10];
```

现在 *balance* 是一个可用的数组，可以容纳 10 个类型为 double 的数字。

### 2. 初始化数组

在 C++ 中，您可以逐个初始化数组，也可以使用一个初始化语句，如下所示：

```
double balance[5] = {1000.0, 2.0, 3.4, 7.0, 50.0};
```

大括号 { } 之间的值的数目不能大于我们在数组声明时在方括号 [ ] 中指定的元素数目。

如果您省略掉了数组的大小，数组的大小则为初始化时元素的个数。因此，如果：

```
double balance[] = {1000.0, 2.0, 3.4, 7.0, 50.0};
```

您将创建一个数组，它与前一个实例中所创建的数组是完全相同的。下面是一个为数组中某个元素赋值的实例：

```
balance[4] = 50.0;
```

上述的语句把数组中第五个元素的值赋为 50.0。所有的数组都是以 0 作为它们第一个元素的索引，也被称为基索引，数组的最后一个索引是数组的总大小减去 1。以下是上面所讨论的数组的的图形表示：

![数组表示](https://gitee.com/song-zhangyao/mapdepot1/raw/master/typora/202111031429673.jpg)

### 3. 获取数组长度

- `sizeof(arr)`: 表示整个数组占用的空间
- `sizeof(arr[0])`: 每个元素占用的内存空间

```c++
int length = sizeof(arr)/sizeof(arr[0]);
```

- 获取数组首地址：`(int)arr`
- 数组中第一个元素的地址：`(int)&arr[0]`
- 数组中给第二个元素的地址：`(int)&arr[1]`

### 4. 访问数组元素

数组元素可以通过数组名称加索引进行访问。元素的索引是放在方括号内，跟在数组名称的后边。例如：

```
double salary = balance[9];
```

上面的语句将把数组中第 10 个元素的值赋给 salary 变量。下面的实例使用了上述的三个概念，即，声明数组、数组赋值、访问数组：

**实例**

```c++
#include <iostream>
using namespace std;
#include <iomanip>
using std::setw;
int main()
{
    int n[10]; // n 是一个包含 10 个整数的数组
    // 初始化数组元素
    for (int i = 0; i < 10; i++)
    {
        n[i] = i + 100;  // 设置元素 i 为 i + 100   }
        cout << "Element" << setw(13) << "Value" << endl; // 输出数组中每个元素的值
        for (int j = 0; j < 10; j++)
        {
            cout << setw(7) << j << setw(13) << n[j] << endl;
        }
        return 0;
    }
}
```

- 
- **输出结果**<img src="https://gitee.com/song-zhangyao/mapdepot1/raw/master/typora/202111031429121.png" alt="image-20211021193040637" width=200 />



### 5. 冒泡排序

```c++
int temp = 0;
//排序过程
for (int i = 0; i < arr.length - 1; i++) {
    for (int j = 0; j < arr.length - 1 - i; j++) {
        if (arr[j] > arr[j + 1]) {
            temp = arr[j];
            arr[j] = arr[j + 1];
            arr[j + 1] = temp;
        }
    }
}
```



---

## 0023 二维数组

多维数组最简单的形式是二维数组。一个二维数组，在本质上，是一个一维数组的列表。声明一个 x 行 y 列的二维整型数组，形式如下：

```c++
type arrayName [ x ][ y ];
```

其中，**type** 可以是任意有效的 C++ 数据类型，**arrayName** 是一个有效的 C++ 标识符。

一个二维数组可以被认为是一个带有 x 行和 y 列的表格。下面是一个二维数组，包含 3 行和 4 列：

![C++ 中的二维数组](https://gitee.com/song-zhangyao/mapdepot1/raw/master/typora/202111031429069.jpg)

因此，数组中的每个元素是使用形式为 a[ i , j ] 的元素名称来标识的，其中 a 是数组名称，i 和 j 是唯一标识 a 中每个元素的下标。

### 初始化二维数组

- 四种初始化方式

  ```c++
  int arr2[2][3] = {{1,2,3,{1,3,5}};
  int arr3[2][3] = {1,2,3,4,5,6};
  int arr4[][3] = {1,2,3,5,6,7};
  ```

  

多维数组可以通过在括号内为每行指定值来进行初始化。下面是一个带有 3 行 4 列的数组。

```c++
int a[3][4] = {  
 {0, 1, 2, 3} ,   /*  初始化索引号为 0 的行 */
 {4, 5, 6, 7} ,   /*  初始化索引号为 1 的行 */
 {8, 9, 10, 11}   /*  初始化索引号为 2 的行 */
};
```

内部嵌套的括号是可选的，下面的初始化与上面是等同的：

```c++
int a[3][4] = {0,1,2,3,4,5,6,7,8,9,10,11};
```

### 访问二维数组元素

二维数组中的元素是通过使用下标（即数组的行索引和列索引）来访问的。例如：

```c++
int val = a[2][3];
```

上面的语句将获取数组中第 3 行第 4 个元素。您可以通过上面的示意图来进行验证。让我们来看看下面的程序，我们将使用嵌套循环来处理二维数组：

### 获取二维数组的长度

- 获取行数

  ```c++
  int Rows  = sizeof(arr)/szieof(arr[0]);
  ```

- 获取列数

  ```c++
  int columns = sizeof(arr[0])/sizeof(arr[0][0]);
  ```

- 元素个数

  ```c++
  int length = sizeof(arr)/sizeof(arr[0][0]);
  ```

## 0024 数组详解

在 C++ 中，数组是非常重要的，我们需要了解更多有关数组的细节。下面列出了 C++ 程序员必须清楚的一些与数组相关的重要概念：

| 概念                                                         | 描述                                                         |
| :----------------------------------------------------------- | :----------------------------------------------------------- |
| [多维数组](https://www.runoob.com/cplusplus/cpp-multi-dimensional-arrays.html) | C++ 支持多维数组。多维数组最简单的形式是二维数组。           |
| [指向数组的指针](https://www.runoob.com/cplusplus/cpp-pointer-to-an-array.html) | 您可以通过指定不带索引的数组名称来生成一个指向数组中第一个元素的指针。 |
| [传递数组给函数](https://www.runoob.com/cplusplus/cpp-passing-arrays-to-functions.html) | 您可以通过指定不带索引的数组名称来给函数传递一个指向数组的指针。 |
| [从函数返回数组](https://www.runoob.com/cplusplus/cpp-return-arrays-from-function.html) | C++ 允许从函数返回数组。                                     |

----

# Day-06 函数

## 0025 function

函数是一组一起执行一个任务的语句。每个 C++ 程序都至少有一个函数，即主函数 **main()** ，所有简单的程序都可以定义其他额外的函数。

可以把代码划分到不同的函数中。如何划分代码到不同的函数中是由您来决定的，但在逻辑上，划分通常是根据每个函数执行一个特定的任务来进行的。

函数**声明**告诉编译器函数的名称、返回类型和参数。函数**定义**提供了函数的实际主体。

C++ 标准库提供了大量的程序可以调用的内置函数。例如，函数 **strcat()** 用来连接两个字符串，函数 **memcpy()** 用来复制内存到另一个位置。

函数还有很多叫法，比如方法、子例程或程序，等等。

### 定义函数

C++ 中的函数定义的一般形式如下：

```c++
return_type function_name( parameter list ) {  
    body of the function 
}
```

在 C++ 中，函数由一个函数头和一个函数主体组成。下面列出一个函数的所有组成部分：

- **返回类型：**一个函数可以返回一个值。**return_type** 是函数返回的值的数据类型。有些函数执行所需的操作而不返回值，在这种情况下，return_type 是关键字 **void**。
- **函数名称：**这是函数的实际名称。函数名和参数列表一起构成了函数签名。
- **参数：**参数就像是占位符。当函数被调用时，您向参数传递一个值，这个值被称为实际参数。参数列表包括函数参数的类型、顺序、数量。参数是可选的，也就是说，函数可能不包含参数。
- **函数主体：**函数主体包含一组定义函数执行任务的语句。

**实例**

以下是 **max()** 函数的源代码。该函数有两个参数 num1 和 num2，会返回这两个数中较大的那个数：

```c++
//函数返回两个数中较大的那个数 
int max(int num1, int num2)  {  
    // 局部变量声明  
    int result;   
    if (num1 > num2)    
        result = num1;  
    else      
        result = num2;    
    return result;  
}
```



### 函数声明

函数**声明**会告诉编译器函数名称及如何调用函数。函数的实际主体可以==单独定义==。

函数声明包括以下几个部分：

```c++
return_type function_name( parameter list );
```

针对上面定义的函数 max()，以下是函数声明：

```c++
int max(int num1, int num2);
```

在函数声明中，参数的名称并不重要，只有参数的类型是必需的，因此下面也是有效的声明：

```c++
int max(int, int);
```

当您在一个源文件中定义函数且在另一个文件中调用函数时，函数声明是必需的。在这种情况下，您应该在调用函数的文件顶部声明函数。

### 调用函数

创建 C++ 函数时，会定义函数做什么，然后通过调用函数来完成已定义的任务。

当程序调用函数时，程序控制权会转移给被调用的函数。被调用的函数执行已定义的任务，当函数的返回语句被执行时，或到达函数的结束括号时，会把程序控制权交还给主程序。

调用函数时，传递所需参数，如果函数返回一个值，则可以存储返回值。例如：

**实例**

```C++
#include <iostream> using namespace std;  
// 函数声明 
int max(int num1, int num2);  
int main () { 
    // 局部变量声明   
	int a = 100;  
    int b = 200;  
    int ret;   
    // 调用函数来获取最大值  
    ret = max(a, b);   
    cout << "Max value is : " << ret << endl;   
    return 0; 
}  
// 函数返回两个数中较大的那个数 
int max(int num1, int num2) { 
    // 局部变量声明   
    int result;    
    if (num1 > num2)   
        result = num1; 
    else      
        result = num2;   
    return result; 
}
```

把 max() 函数和 main() 函数放一块，编译源代码。当运行最后的可执行文件时，会产生下列结果：

```c++
Max value is : 200
```

### 函数参数

如果函数要使用参数，则必须声明接受参数值的变量。这些变量称为函数的**形式参数**。

形式参数就像函数内的其他局部变量，在进入函数时被创建，退出函数时被销毁。

当调用函数时，有三种向函数传递参数的方式：

| 调用类型                                                     | 描述                                                         |
| :----------------------------------------------------------- | :----------------------------------------------------------- |
| [传值调用](https://www.runoob.com/cplusplus/cpp-function-call-by-value.html) | 该方法把参数的实际值赋值给函数的形式参数。在这种情况下，修改函数内的形式参数对实际参数没有影响。 |
| [指针调用](https://www.runoob.com/cplusplus/cpp-function-call-by-pointer.html) | 该方法把参数的地址赋值给形式参数。在函数内，该地址用于访问调用中要用到的实际参数。这意味着，修改形式参数会影响实际参数。 |
| [引用调用](https://www.runoob.com/cplusplus/cpp-function-call-by-reference.html) | 该方法把参数的引用赋值给形式参数。在函数内，该引用用于访问调用中要用到的实际参数。这意味着，修改形式参数会影响实际参数。 |

默认情况下，C++ 使用**传值调用**来传递参数。一般来说，这意味着函数内的代码不能改变用于调用函数的参数。之前提到的实例，调用 max() 函数时，使用了相同的方法。

### 参数的默认值

当您定义一个函数，您可以为参数列表中后边的每一个参数指定默认值。当调用函数时，如果实际参数的值==留空==，则使用这个默认值。

```c++
int sum(int a, int b = 20) {
    return a + b;
}
```

---

## 0026 函数的分文件

- 作用：让代码结构更加清晰

- 函数分文件编写一般有4个步骤
  1. 创建后缀名为`.h`的头文件
  2. 创建后缀名为`.cpp`的源文件
  3. 在头文件中写函数的声明
  4. 在源文件中写函数的定义

# Day-07 指针

## 0027 指针的基本概念

指针的作用：可以==通过指针间接访问内存==

- 内存编号是从0开始记录的，一般用十六进制数字表示
- 可以利用指针变量保存地址--指针就是地址

**指针变量的定义和使用**

- 指针变量定义语法：`数据类型*变量名`;

  - 示例：`int * p`

  ```c++
  int a = 10;
  int *p;
  //让指针记录a的地址
  p = &a;//指针就是地址
  cout << "a的地址：" << &a << endl;//16进制：0x61fe14
  cout << "指针p：" << p << endl;//0x61fe14
  //    2、使用指针
  //            可以通过解引用的方式来找到指针指向的内存
  //    指针前加*代表解引用,找到指针指向的内存中的数据
  *p = 1000;//更改地址
  cout << *p << endl;
  ```

  

## 0028 指针占用的内存空间

- 简化写法

  ```c++
  int *p;
  p = &a;//指针就是地址
  ```

  - 等价于

    ```c++
    int *p = &a;
    ```

    

- 在32位操作系统下：占用4个字节空间；64位下占8个字节。

  ```c++
      int a = 10;
      int *p = &a;
      cout<<sizeof(p)<<endl;//8, 这儿也可以写int*
      cout<<sizeof(*p)<<endl;//4
  ```

  

## 0029 空指针和野指针

- 空指针：指针变量指向内存中编号为0的空间
  - 用途：初始化指针变量
  - 注意：**空指针指向的内存是不可以访问的**

- 野指针：指针变量指向==非法的内存空间==
  - 注意：程序中应该尽量避免

> 总结：空指针和野指针都不是我们申请的空间,因此不要访问

## 0030 const修饰指针

- const修饰指针有三种情况

  1. const修饰指针----常量指针

     - `const int *p = &a;`

     - 特点：指针的指向可以修改，但是指针==指向的值==不可以。

       ```c++
           int a = 10;
           int b = 30;
           const int *p = &a;
       //    *p == 20;//错误写法，const修饰得指针变量，其指向得值不能更改
           cout << *p << endl;//10
           p = &b;
           cout << p << endl;//0x61fe10
       ```

       

  2. const修饰常量----指针常量

     - `int *const p = &a;`

     - 特点：指针的指向不可以改，指针==指向的值==可以改

       ```c++
       int a = 10;
       int b = 30;
       int *const p = &a;
       *p = 40;
       cout << *p << endl;//40
       //    p = &b;//不可以更改指针的指向
       cout << p << endl;//0x61fe0c
       ```

       

  3. const即修饰指针，又修饰常量

     - `const int *const p = &a;`

     - 指针指向的值和指针的指向(地址)都不可以更改

       ```c++
       int a = 10;
       const int *const p = &a;
       cout << p << endl;//0x61fe14
       cout << *p << endl;//10
       ```

       

## 0031 指针和数组

- 利用指针访问数组的元素

  ```c++
  int arr[10] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
  int *p = arr;//arr就是数组首地址
  for (int i = 0; i < 10; i++) {
      //三种方式一样的
      cout << arr[i] << endl;
      cout << *(p++) << endl;
      cout << *(arr + i) << endl;
  }
  ```

  

## 0032指针和函数

- 作用：利用指针作函数参数，可以**修改实参的值**。

  ```c++
  //1. 值传递
  void swap1(int a, int b) {
      int temp = a;
      a = b;
      b = temp;
      cout << "swap1_a=" << a << ", swap1_b=" << b << endl;
  }
  
  //2. 地址传递
  void swap2(int *p1, int *p2) {
      int temp = *p1;
      *p1 = *p2;
      *p2 = temp;
      cout << "swap2_a=" << *p1 << ", swap2_b=" << *p2 << endl;
  }
  
  int main() {
      //1. 值传递
      int a = 10;
      int b = 100;
      swap1(a, b);
      cout << "1.a=" << a << ", b=" << b << endl;//a=10, b=100;实参并未改变
      //2. 地址传递
      swap2(&a,&b);
      cout << "2.a=" << a << ", b=" << b << endl;//a=100, b=10;实参改变
  
      return 0;
  }
  ```

  

# Day-08 结构体

- 基本概念：

  结构体属于==用户自定义==的数据类型，允许用户存储不同的数据类型。

## 0033 结构体定义与使用

- **语法**:：`struct 结构体名 {结构体成员列表};`

- 通过结构体创建变量的方式有三种

  1. `struct 结构体名 变量名;`

  2. `struct 结构体名 变量名 = {成员1值, 成员2值…};`

  3. 定义结构体时顺便创建变量

     ```c++
     #include "iostream"
     using namespace std;
     //创建学生数据类型：姓名，年龄，分数
     //自定义数据类型
     struct Student {//struct必须存在 
         string name;
         int age;
         double score;
     } s3, s4;//s3,s4,...:定义结构体时顺便创建变量
     
     int main() {
         
     //创建学生对象
     //1.struct Student s1;
     
     //3.定义结构体时顺便创建变量
         struct Student s1;
         s1.name = "Tom";
         s1.age = 34;
         s1.score = 89.67;
         //2.struct Student s2 = {....};
         struct Student s2 = {"jack", 18, 89.5};
         s3.name = "smith";
         s3.age = 23;
         s3.score = 89;
         cout << "name\t" << "age\t" << "score" << endl;
         cout << s1.name << "\t" << s1.age << "\t" << s1.score << endl;
         cout << s2.name << "\t" << s2.age << "\t" << s2.score << endl;
         cout << s3.name << "\t" << s3.age << "\t" << s3.score << endl;
         return 0;
     }
     
     
     ```

     - 注意：创建变量时：struct关键字可以省略。

## 0034 结构体数组

- 作用：将自定义的结构体放入到数组中方便维护

- 语法： `struct 结构体名 数组名[元素个数] = { {},{},…{}};`

  - 示例：对于上面得学生结构体，创建学生类结构体数组。

    ```c++
    struct Student students[3] = {{"jack",  16, 78},
                                  {"tom",   19, 90},
                                  {"smith", 24, 67}};
    ```

  - 如何访问数组元素

    ```c++
    for (int i = 0; i < 3; i++) {
        cout << (*(students + i)).name << ",";
        cout << (*(students + i)).age << ",";
        cout << (*(students + i)).score << endl;
    }
    ```

    

## 0035 结构体指针

- 作用：通过指针访问结构体中的成员

- 利用操作符->可以通过结构体指针访问==结构体属性==。

  

- 示例：用箭头访问

  ```c++
  Student s = {"张三", 34, 90};
  Student *p = &s;
  cout << p->name << ", " << p->age << ", " << p->score << endl;
  cout << (*p).name << ", " << (*p).age << ", " << (*p).score << endl;
  ```

  - 结果<img src="C:/Users/szy/AppData/Roaming/Typora/typora-user-images/image-20211104124947926.png" alt="image-20211104124947926" width=200 />

## 0036 结构体嵌套

- 作用：结构体中的成员可以是另一个结构体

- 例如：每个老师辅导一个学员，一个老师的结构体中，记录一个学生的结构体。

- 示例：04_struct+nested.cpp

  ```c++
  teacher teachers[] = {
      {"001", "T-1", 34, {"01", "S-2", 21, 89}},
      {"002", "T-2", 56, {"02", "S-1", 19, 67}},
      {"003", "T-3", 78, {"03", "S-3", 20, 10}},
  };
  ```

  
